import Foundation
import Result
#if swift(>=3)
import ReactiveSwift
#else
import ReactiveCocoa
#endif

/// A map of build settings and their values, as generated by Xcode.
public struct BuildSettings {
	/// The target to which these settings apply.
	public let target: String

	/// All build settings given at initialization.
	public let settings: Dictionary<String, String>

	public init(target: String, settings: Dictionary<String, String>) {
		self.target = target
		self.settings = settings
	}

	/// Matches lines of the forms:
	///
	/// Build settings for action build and target "ReactiveCocoaLayout Mac":
	/// Build settings for action test and target CarthageKitTests:
	private static let targetSettingsRegex = try! NSRegularExpression(pattern: "^Build settings for action (?:\\S+) and target \\\"?([^\":]+)\\\"?:$", options: [ .caseInsensitive, .anchorsMatchLines ])

	/// Invokes `xcodebuild` to retrieve build settings for the given build
	/// arguments.
	///
	/// Upon .success, sends one BuildSettings value for each target included in
	/// the referenced scheme.
	public static func loadWithArguments(arguments: BuildArguments) -> SignalProducer<BuildSettings, Error> {
		// xcodebuild (in Xcode 8) has a bug where xcodebuild -showBuildSettings
		// can hang indefinitely on projects that contain core data models.
		// rdar://27052195
		// Including the action "clean" works around this issue, which is further
		// discussed here: https://forums.developer.apple.com/thread/50372
		let task = xcodebuildTask(["clean", "-showBuildSettings", "-skipUnavailableActions"], arguments)

		return task.launch()
			.ignoreTaskData()
			.mapError(Error.taskError)
			// xcodebuild has a bug where xcodebuild -showBuildSettings
			// can sometimes hang indefinitely on projects that don't
			// share any schemes, so automatically bail out if it looks
			// like that's happening.
			.timeout(after: 60, raising: .xcodebuildTimeout(arguments.project), on: QueueScheduler(qos: QOS_CLASS_DEFAULT))
			.retry(upTo: 5)
			.map { data in
				return String(data: data, encoding: .utf8)!
			}
			.flatMap(.merge) { string -> SignalProducer<BuildSettings, Error> in
				return SignalProducer { observer, disposable in
					var currentSettings: [String: String] = [:]
					var currentTarget: String?

					let flushTarget = { () -> () in
						if let currentTarget = currentTarget {
							let buildSettings = self.init(target: currentTarget, settings: currentSettings)
							observer.send(value: buildSettings)
						}

						currentTarget = nil
						currentSettings = [:]
					}

					string.enumerateLines { line, stop in
						if disposable.isDisposed {
							stop = true
							return
						}

						if let result = self.targetSettingsRegex.firstMatch(in: line, range: NSMakeRange(0, line.utf16.count)) {
							let targetRange = result.rangeAt(1)

							flushTarget()
							currentTarget = (line as NSString).substring(with: targetRange)
							return
						}

						let trimSet = CharacterSet.whitespacesAndNewlines
						let components = line.characters
							.split(maxSplits: 1) { $0 == "=" }
							.map { String($0).trimmingCharacters(in: trimSet) }

						if components.count == 2 {
							currentSettings[components[0]] = components[1]
						}
					}

					flushTarget()
					observer.sendCompleted()
				}
			}
	}

	/// Determines which SDKs the given scheme builds for, by default.
	///
	/// If an SDK is unrecognized or could not be determined, an error will be
	/// sent on the returned signal.
	public static func SDKsForScheme(scheme: String, inProject project: ProjectLocator) -> SignalProducer<SDK, Error> {
		return loadWithArguments(BuildArguments(project: project, scheme: scheme))
			.take(first: 1)
			.flatMap(.merge) { $0.buildSDKs }
	}

	/// Returns the value for the given build setting, or an error if it could
	/// not be determined.
	public subscript(key: String) -> Result<String, Error> {
		if let value = settings[key] {
			return .success(value)
		} else {
			return .failure(.missingBuildSetting(key))
		}
	}

	/// Attempts to determine the SDKs this scheme builds for.
	public var buildSDKs: SignalProducer<SDK, Error> {
		let supportedPlatforms = self["SUPPORTED_PLATFORMS"]

		if let supportedPlatforms = supportedPlatforms.value {
			let platforms = supportedPlatforms.characters.split { $0 == " " }.map(String.init)
			return SignalProducer<String, Error>(platforms)
				.map { platform in SignalProducer(result: SDK.from(string: platform)) }
				.flatten(.merge)
		}

		let firstBuildSDK = self["PLATFORM_NAME"].flatMap(SDK.from(string:))
		return SignalProducer(result: firstBuildSDK)
	}

	/// Attempts to determine the ProductType specified in these build settings.
	public var productType: Result<ProductType, Error> {
		return self["PRODUCT_TYPE"].flatMap(ProductType.from(string:))
	}

	/// Attempts to determine the MachOType specified in these build settings.
	public var machOType: Result<MachOType, Error> {
		return self["MACH_O_TYPE"].flatMap(MachOType.from(string:))
	}

	/// Attempts to determine the FrameworkType identified by these build settings.
	internal var frameworkType: Result<FrameworkType?, Error> {
		return productType.fanout(machOType).map(FrameworkType.init)
	}

	/// Attempts to determine the URL to the built products directory.
	public var builtProductsDirectoryURL: Result<URL, Error> {
		return self["BUILT_PRODUCTS_DIR"].map { productsDir in
			return URL(fileURLWithPath: productsDir, isDirectory: true)
		}
	}

	/// Attempts to determine the relative path (from the build folder) to the
	/// built executable.
	public var executablePath: Result<String, Error> {
		return self["EXECUTABLE_PATH"]
	}

	/// Attempts to determine the URL to the built executable.
	public var executableURL: Result<URL, Error> {
		return builtProductsDirectoryURL
			.fanout(executablePath)
			.map { builtProductsURL, executablePath in
				return builtProductsURL.appendingPathComponent(executablePath)
			}
	}

	/// Attempts to determine the name of the built product's wrapper bundle.
	public var wrapperName: Result<String, Error> {
		return self["WRAPPER_NAME"]
	}

	/// Attempts to determine the URL to the built product's wrapper.
	public var wrapperURL: Result<URL, Error> {
		return builtProductsDirectoryURL
			.fanout(wrapperName)
			.map { builtProductsURL, wrapperName in
				return builtProductsURL.appendingPathComponent(wrapperName)
			}
	}

	/// Attempts to determine whether bitcode is enabled or not.
	public var bitcodeEnabled: Result<Bool, Error> {
		return self["ENABLE_BITCODE"].map { $0 == "YES" }
	}

	/// Attempts to determine the relative path (from the build folder) where
	/// the Swift modules for the built product will exist.
	///
	/// If the product does not build any modules, `nil` will be returned.
	internal var relativeModulesPath: Result<String?, Error> {
		if let moduleName = self["PRODUCT_MODULE_NAME"].value {
			return self["CONTENTS_FOLDER_PATH"].map { contentsPath in
				let path1 = (contentsPath as NSString).appendingPathComponent("Modules")
				let path2 = (path1 as NSString).appendingPathComponent(moduleName)
				return (path2 as NSString).appendingPathExtension("swiftmodule")
			}
		} else {
			return .success(nil)
		}
	}

	/// Attempts to determine the code signing identity.
	public var codeSigningIdentity: Result<String, Error> {
		return self["CODE_SIGN_IDENTITY"]
	}

	/// Attempts to determine if ad hoc code signing is allowed.
	public var adHocCodeSigningAllowed: Result<Bool, Error> {
		return self["AD_HOC_CODE_SIGNING_ALLOWED"].map { $0 == "YES" }
	}
}

extension BuildSettings: CustomStringConvertible {
	public var description: String {
		return "Build settings for target \"\(target)\": \(settings)"
	}
}
